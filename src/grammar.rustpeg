/*============================================================================
  Copyright (C) 2017 akitsu sanae
  https://github.com/akitsu-sanae/alcl
  Distributed under the Boost Software License, Version 1.0. (See accompanying
  file LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)
============================================================================*/

use super::ast::*;

pub program -> Program
  = __ struct_defs:struct_define* funcs:function* {
      Program {
        functions: funcs,
        struct_data: struct_defs,
      }
  }

struct_define -> StructType
  = STRUCT name:type_name LBRACE data:(id:variable_name COLON ty:type_ { (id, ty) })* RBRACE {
      StructType {
        name: name,
        data: data.into_iter().collect(),
      }
  }

type_ -> Type
  = name:type_name {
      match name.as_str() {
          "Char" => Type::Char,
          "Int" => Type::Int,
          _ => Type::Struct(name)
      }
  }

function -> Function
  = FUNC name:variable_name params:(name:variable_name COLON ty:type_ { (name, ty) })* COLON ret_ty:type_ body:block_expr {
      Function {
name: name,
          args: params,
          return_type: ret_ty,
          body: body
      }
  }

expr -> Expr
  = let_expr

let_expr -> Expr
  = LET name:variable_name EQUAL init:inline_expr {
    Expr::Let(name, box init)
  }
  /inline_expr

inline_expr -> Expr
  = if_expr

if_expr -> Expr
  = IF cond:bin_expr then:block_expr ELSE els:block_expr {
      Expr::If(box cond, box then, box els)
  }
  / bin_expr

bin_expr -> Expr
  = #infix<primary_expr> {
    #L l PLUS r { Expr::Add(box l, box r) }
       l MINUS r { Expr::Sub(box l, box r) }
    #L l STAR r { Expr::Mult(box l, box r) }
       l SLASH r { Expr::Div(box l, box r) }
  }

primary_expr -> Expr
  = LPAREN e:expr RPAREN { e }
  / block_expr
  / literal
  / name:variable_name { Expr::Var(name) }

literal -> Expr
  = n:number { Expr::Int(n) }
  / name:type_name LBRACE data:(name:variable_name COLON e:expr { (name, e) })* RBRACE {
      let fields = data.into_iter().collect();
      Expr::Struct(name, fields)
  }

block_expr -> Expr
  = LBRACE es:(e:expr SEMICOLON { e })* last:expr RBRACE {
      let mut exprs = es;
      exprs.push(last);
      Expr::Block(exprs)
  }

PLUS = "+" __
MINUS = "-" __
STAR = "*" __
SLASH = "/" __
EQUAL = "=" __
LPAREN = "(" __
RPAREN = ")" __
LBRACE = "{" __
RBRACE = "}" __
COLON = ":" __
SEMICOLON = ";" __
SINGLE_QUOTE = "'" __

keyword<E> = E !([a-zA-Z0-9_]) __

STRUCT = keyword<"struct">
FUNC = keyword<"func">
LET = keyword<"let">
IF = keyword<"if">
ELSE = keyword<"else">
NEW = keyword<"new">
PRINTLN = keyword<"println">

number -> i64
  = n:$([0-9]+) __ { i64::from_str_radix(n, 10).unwrap() }

string -> String
  = "\"" s:$([^\"]*) "\"" __ { s.to_string() }

space = [ \n\t]
comment = "//" (!eol .)*
eol = "\n"
__ = #quiet<(space / eol / comment)*>

snake_identifier -> String
  = #quiet<s:$([a-z_][a-z0-9_]*) __ { s.to_string() }>
  / #expected("snake-cased identifier")

camel_identifier -> String
  = #quiet<s:$([A-Z][a-zA-Z0-9]*) __ { s.to_string() }>
  / #expected("camel-cased identifier")

type_name -> String = camel_identifier
variable_name -> String = snake_identifier

