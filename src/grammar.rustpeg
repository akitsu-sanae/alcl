/*============================================================================
  Copyright (C) 2017 akitsu sanae
  https://github.com/akitsu-sanae/alcl
  Distributed under the Boost Software License, Version 1.0. (See accompanying
  file LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)
============================================================================*/

use super::ast::*;

pub program -> Program
  = __ struct_defs:struct_define* funcs:function* {
      Program {
        functions: funcs,
        struct_data: struct_defs,
      }
  }

struct_define -> StructType
  = STRUCT name:identifier LBRACE data:(id:identifier COLON ty:type_ { (id, ty) })* {
      StructType {
        name: name,
        data: data.into_iter().collect()
      }
  }

type_ -> Type
  = name:identifier {
      match name.as_str() {
          "Char" => Type::Char,
          "Int" => Type::Int,
          _ => Type::Struct(name)
      }
  }

function -> Function
  = FUNC name:identifier params:(name:identifier COLON ty:type_ { (name, ty) })* COLON ret_ty:type_ LBRACE body:function_body RBRACE {
      Function {
name: name,
          args: params,
          return_type: ret_ty,
          body: body
      }
  }

function_body -> (Vec<Statement>, Expr)
    = stmts:statement* e:expr {
        (stmts, e)
    }

statement -> Statement
  = LET name:identifier EQUAL init:expr SEMICOLON {
      Statement::Let(name, init)
  }
  / PRINTLN e:expr SEMICOLON {
      Statement::Println(e)
  }
  / e:expr SEMICOLON {
      Statement::Expression(e)
  }

expr -> Expr
  = if_expr

if_expr -> Expr
  = IF LPAREN cond:bin_expr RPAREN tr:expr ELSE fl:expr {
      Expr::If(box cond, box tr, box fl)
  }
  / bin_expr

bin_expr -> Expr
  = #infix<primary_expr> {
    #L l PLUS r { Expr::Add(box l, box r) }
       l MINUS r { Expr::Sub(box l, box r) }
    #L l STAR r { Expr::Mult(box l, box r) }
       l SLASH r { Expr::Div(box l, box r) }
  }

primary_expr -> Expr
  = v:literal  { Expr::Literal(v) }
  / LBRACE e:expr RBRACE { e }
  / name:identifier { Expr::Var(name) }

literal -> Literal
  = SINGLE_QUOTE c:$(.) SINGLE_QUOTE { Literal::Char(c.chars().nth(0).unwrap()) }
  / n:number { Literal::Int(n) }
  / str:string { Literal::String(str) }
  / NEW name:identifier LBRACE data:(name:identifier COLON e:expr { (name, e) })* RBRACE {
      Literal::Struct(StructLiteral {
            name: name,
            data: data.into_iter().collect()
          })
  }

__ = [ \n\t]*

PLUS = "+" __
MINUS = "-" __
STAR = "*" __
SLASH = "/" __
EQUAL = "=" __
LPAREN = "(" __
RPAREN = ")" __
LBRACE = "{" __
RBRACE = "}" __
COLON = ":" __
SEMICOLON = ";" __
SINGLE_QUOTE = "'" __

keyword<E> = E !([a-zA-Z0-9_]) __

STRUCT = keyword<"struct">
FUNC = keyword<"func">
LET = keyword<"let">
IF = keyword<"if">
ELSE = keyword<"else">
NEW = keyword<"new">
PRINTLN = keyword<"println">

number -> i64
  = n:$([0-9]+) __ { n.parse().unwrap() }

identifier -> String
  = s:$([a-zA-Z_][a-zA-Z0-9_]*) __ { s.to_string() }

string -> String
  = "\"" s:$([^\"]*) "\"" __ { s.to_string() }

spaces = [ \n\t]*

line_spaces = [ \t]*

